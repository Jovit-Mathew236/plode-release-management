name: Update Meta and Create Firmware Release

on:
  push:
    branches:
      - main
    paths:
      - "**/*"

permissions:
  contents: write

jobs:
  update-meta:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install pyyaml

      - name: Detect changed firmware folders and files
        id: detect
        run: |
          git diff --name-status HEAD~1 HEAD > /tmp/changed_files.txt || true
          > /tmp/firmware_folders_existing.txt
          > /tmp/firmware_folders_deleted.txt

          while read status path; do
            [ -z "$path" ] && continue
            top=$(echo "$path" | cut -d'/' -f1)

            # Skip non-firmware / system files
            case "$top" in
              .* | LICENSE | README* ) continue ;;
            esac

            if [ -d "$top" ]; then
              echo "$top" >> /tmp/firmware_folders_existing.txt
            else
              if [ "$status" = "D" ]; then
                echo "$top" >> /tmp/firmware_folders_deleted.txt
              fi
            fi
          done < /tmp/changed_files.txt

          sort -u /tmp/firmware_folders_existing.txt -o /tmp/firmware_folders_existing.txt || true
          sort -u /tmp/firmware_folders_deleted.txt -o /tmp/firmware_folders_deleted.txt || true

          folders=$(cat /tmp/firmware_folders_existing.txt | tr '\n' ' ' || true)
          deleted=$(cat /tmp/firmware_folders_deleted.txt | tr '\n' ' ' || true)

          echo "folders=$folders" >> $GITHUB_OUTPUT
          echo "deleted=$deleted" >> $GITHUB_OUTPUT

      - name: Check for unauthorized meta.yaml edits
        id: protect
        run: |
          echo "Checking for manually edited meta.yaml files..."
          edited_meta=$(git diff --name-only HEAD~1 HEAD | grep "meta.yaml" || true)

          if [ -z "$edited_meta" ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          unauthorized_files=()
          for f in $edited_meta; do
            author=$(git log -1 --pretty=format:'%an' -- "$f" || true)
            if [ "$author" != "github-actions[bot]" ]; then
              unauthorized_files+=("$f")
            fi
          done

          if [ ${#unauthorized_files[@]} -eq 0 ]; then
            echo "no_meta_edit=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          for f in "${unauthorized_files[@]}"; do
            echo "Reverting unauthorized edit in $f"
            git checkout HEAD~1 -- "$f" || true
          done

          # Check if ONLY meta.yaml was changed (no firmware file changes)
          non_meta=$(git diff --name-only HEAD~1 HEAD | grep -v "meta.yaml" || true)
          if [ -z "$non_meta" ]; then
            echo "only_meta_edit=true" >> $GITHUB_OUTPUT
          else
            echo "only_meta_edit=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop pipeline if only meta.yaml was edited manually
        if: steps.protect.outputs.only_meta_edit == 'true'
        run: |
          echo "Unauthorized meta.yaml edit detected."
          echo "Reverted to previous version. No update or release will be created."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add --all
          git commit -m "Revert unauthorized meta.yaml edit" || true
          git push origin main || true
          exit 0

      - name: Update meta.yaml files
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
        run: |
          import os, yaml, datetime, subprocess, sys

          folders = os.environ.get("FOLDERS", "").split()
          if not folders or folders == ['']:
              sys.exit(0)

          for folder in folders:
              if not os.path.isdir(folder):
                  print(f"Skipping {folder} (not a directory)")
                  continue

              meta_path = os.path.join(folder, "meta.yaml")
              data = {}
              if os.path.exists(meta_path):
                  with open(meta_path) as f:
                      data = yaml.safe_load(f) or {}

              version = float(data.get("version", 0))
              version = round(version + 0.1, 1)

              now_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()
              data.update({
                  "version": version,
                  "last_updated": now_utc,
                  "last_commit": subprocess.getoutput("git rev-parse HEAD"),
                  "folder": folder
              })

              with open(meta_path, "w") as f:
                  yaml.dump(data, f)

              print(f"Updated {meta_path} -> version {version}")

        shell: python

      - name: Commit and push updated meta.yaml (if any)
        if: steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
        run: |
          folders="${FOLDERS}"
          files_to_add=""
          for folder in $folders; do
            if [ -f "$folder/meta.yaml" ]; then
              files_to_add="$files_to_add $folder/meta.yaml"
            fi
          done

          if [ -z "$files_to_add" ]; then
            echo "No meta.yaml files to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add $files_to_add

          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Auto-update meta.yaml"
            git push origin main
          fi

      - name: Create or update GitHub releases per firmware
        if: steps.detect.outputs.folders != '' && steps.protect.outputs.only_meta_edit != 'true'
        env:
          FOLDERS: ${{ steps.detect.outputs.folders }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Starting release creation/update..."
          git diff --name-only HEAD~1 HEAD > /tmp/changed_files.txt || true

          for folder in $FOLDERS; do
            [ ! -d "$folder" ] && continue

            meta_path="${folder}/meta.yaml"
            version=$(grep '^version:' "$meta_path" | awk '{print $2}')
            tag="${folder}-v${version}"

            changed_files=$(grep "^${folder}/" /tmp/changed_files.txt | grep -v "meta.yaml" || true)
            if [ -z "$changed_files" ]; then
              echo "No firmware files changed in $folder; skipping release."
              continue
            fi

            if gh release view "$tag" >/dev/null 2>&1; then
              echo "Updating existing release for $folder (tag: $tag)"
            else
              echo "Creating new release for $folder (tag: $tag)"
              gh release create "$tag" --title "$folder" \
                --notes "Automated firmware release for $folder (v${version})." \
                --target main
            fi

            upload_list="$changed_files $meta_path"
            for f in $upload_list; do
              if [ -f "$f" ]; then
                gh release upload "$tag" "$f" --clobber || true
              fi
            done

            added=$(git diff --name-status HEAD~1 HEAD | grep "^A" | grep "$folder" || true)
            modified=$(git diff --name-status HEAD~1 HEAD | grep "^M" | grep "$folder" || true)
            deleted=$(git diff --name-status HEAD~1 HEAD | grep "^D" | grep "$folder" || true)

            notes="Automated firmware release for $folder (v${version}).\n\n"
            if [ -n "$added" ]; then notes+="Added:\n${added}\n\n"; fi
            if [ -n "$modified" ]; then notes+="Modified:\n${modified}\n\n"; fi
            if [ -n "$deleted" ]; then notes+="Deleted:\n${deleted}\n"; fi

            gh release edit "$tag" --notes "$notes" || true
          done

      - name: Delete releases for removed firmware folders
        if: steps.detect.outputs.deleted != ''
        env:
          DELETED: ${{ steps.detect.outputs.deleted }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for folder in $DELETED; do
            [ -z "$folder" ] && continue
            echo "Deleting release(s) for removed firmware folder: $folder"
            tags=$(gh release list --limit 1000 --json tagName --jq '.[] | .tagName' | grep "^${folder}-v" || true)
            for tag in $tags; do
              echo "Removing release and tag: $tag"
              gh release delete "$tag" --yes || true
              git tag -d "$tag" || true
              git push origin :refs/tags/"$tag" || true
            done
          done
